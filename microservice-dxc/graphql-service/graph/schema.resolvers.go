package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/golang-jwt/jwt/v4"
	"golang.org/x/crypto/bcrypt"
	"graphql-service/graph/model"
	"log"
	"strconv"
	"time"
)

// CreateArticle is the resolver for the createArticle field.
func (r *mutationResolver) CreateArticle(ctx context.Context, title string, content string) (*model.Article, error) {
	panic(fmt.Errorf("not implemented: CreateArticle - createArticle"))
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, email string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: FollowUser - followUser"))
}

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, name string, email string, password string, bio string) (*model.User, error) {

	//bcrypt generate hash from the password provided
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Println(err)
		return nil, fmt.Errorf("generating password hash %w", err)
	}

	u := model.User{
		Name:  name,
		Email: email,
		Bio:   &bio,
	}

	//constructing query to insert user, and it returns id that is generated by db
	const q = `INSERT INTO users
		(name, email, bio,password_hash, date_created, date_updated)
		VALUES ( $1, $2, $3, $4, $5, $6)
		Returning id`

	var id int

	//executing the query // QueryRowContext exec the query and returns one row back
	row := r.DB.QueryRowContext(ctx, q, u.Name, u.Email, u.Bio, hash, time.Now(), time.Now())
	//saving the value return by db in id var
	err = row.Scan(&id)

	if err != nil {
		log.Println(err)
		return nil, fmt.Errorf("account creation failed %w", err)
	}
	//converting id to string as our struct field store id in string format
	u.ID = strconv.Itoa(id)
	return &u, nil

}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	//this query is used to check whether a user exist in the db or not
	const q = `SELECT id,name,email,password_hash FROM users WHERE email = $1`
	var u model.User
	var passwordHash string

	//exec the query and storing the result in the struct
	err := r.DB.QueryRowContext(ctx, q, email).Scan(&u.ID, &u.Name, &u.Email, &passwordHash)

	if err != nil {
		log.Println(err)
		if err == sql.ErrNoRows {
			return "failed", errors.New("authentication failed")
		}
		return "failed", err
	}

	//comparing the hashed password in db and password provided by the user
	err = bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(password))

	if err != nil {
		log.Println(err)
		return "failed", errors.New("authentication failed")
	}

	//on successful login we will put data in the Claims var, we generate the token using the claims
	claims := jwt.RegisteredClaims{
		Issuer:    "microservice project",
		Subject:   u.Email,
		Audience:  jwt.ClaimStrings{"students"},
		ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),
		IssuedAt:  jwt.NewNumericDate(time.Now()),
	}
	token, err := r.GenerateToken(claims)
	if err != nil {
		log.Println(err)
		return "failed", errors.New("authentication failed")
	}
	return token, nil

}

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context) ([]*model.Article, error) {
	panic(fmt.Errorf("not implemented: Articles - articles"))
}

// Following is the resolver for the following field.
func (r *queryResolver) Following(ctx context.Context) ([]string, error) {
	panic(fmt.Errorf("not implemented: Following - following"))
}

// Followers is the resolver for the followers field.
func (r *queryResolver) Followers(ctx context.Context) ([]string, error) {
	panic(fmt.Errorf("not implemented: Followers - followers"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
