package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"graphql-service/graph/model"
	"graphql-service/proto"
	"io"
	"log"
	"net/http"
	"strconv"
	"time"

	jwt "github.com/golang-jwt/jwt/v4"
	"golang.org/x/crypto/bcrypt"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// CreateArticle is the resolver for the createArticle field.
func (r *mutationResolver) CreateArticle(ctx context.Context, title string, content string) (*model.Article, error) {
	//Checking user token is valid or not
	claims, err := r.A.ValidateSession(ctx)
	if err != nil {
		log.Println(err)
		return nil, errors.New("login required")
	}

	//creating a struct to send it as json to article service
	var jsonReq = struct {
		Title       string `json:"title"`
		Content     string `json:"content"`
		AuthorEmail string `json:"author_email"`
	}{
		Title:       title,
		Content:     content,
		AuthorEmail: claims.Subject,
	}

	//converting struct to json
	b, err := json.Marshal(jsonReq)
	if err != nil {
		return nil, err
	}

	//creating context with timeout of 10sec // our remote service has to respond in this time or otherwise the request would be cancelled
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// construction of the request // we are using rest based approach to call article service
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, "http://article-service:8080/article/add", bytes.NewReader(b))
	if err != nil {
		return nil, err
	}

	//this error occurs when remote service is unreachable or timeout happened
	//this does not signify if we had a problem in creating resource at the remote server
	response, err := http.DefaultClient.Do(req)

	//reading the response body
	b, err = io.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	//if status code is above 299 which means something definitely went wrong
	if response.StatusCode > 299 {
		log.Println(string(b)) // logging what remote service has sent back as the response
		return nil, fmt.Errorf("create article failed %v", b)
	}

	var article *model.Article

	//unmarshalling the data in the struct if everything is fine
	json.Unmarshal(b, &article)
	fmt.Println(article)

	return article, nil

}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, email string) (*model.User, error) {

	//check if user is logged in or not by validating the token
	claims, err := r.A.ValidateSession(ctx)
	if err != nil {
		log.Println(err)
		return nil, errors.New("login required")
	}

	//checking if user exist or not
	const q = `SELECT id,email from users WHERE email = $1`

	var u model.User
	//exec the query and storing the result in the struct
	err = r.Db.QueryRowContext(ctx, q, email).Scan(&u.ID, &u.Name)
	if err != nil {
		log.Println(err)
		if err == sql.ErrNoRows {
			return nil, errors.New("user doesn't exist")
		}
		return nil, err
	}

	//connecting with the gRPC server
	conn, err := grpc.Dial("follower-service:5000", grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())
	if err != nil {
		log.Println(err)
		return nil, fmt.Errorf("can't dial connection to follower-service %w", err)

	}
	defer conn.Close()

	//registering the gRPC client
	c := proto.NewFollowUserServiceClient(conn)

	//setting up the request struct
	f := &proto.FollowUserRequest{
		User: &proto.UserDetails{
			UserEmail:       claims.Subject,
			TargetUserEmail: email,
		},
	}

	// using context to set timeout of 10 sec for the service to finish the task and complete the result
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	//calling the rpc FollowUser
	res, err := c.FollowUser(ctx, f)

	if err != nil {
		log.Println("can't follow user", err)
		return nil, fmt.Errorf("follow user failed %w", err)
	}

	log.Println("follow user success", res)
	u = model.User{Email: email}
	return &u, nil
}

// Signup is the resolver for the signup field.
// It takes user details and put that in postgres of follower-service.
func (r *mutationResolver) Signup(ctx context.Context, name string, email string, password string, bio string) (*model.User, error) {

	//bcrypt generate hash from the password provided
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Println(err)
		return &model.User{}, fmt.Errorf("generating password hash %w", err)
	}
	u := model.User{
		Name:  name,
		Email: email,
		Bio:   &bio,
	}

	//constructing query to insert user, and it returns id that is generated by db
	const q = `INSERT INTO users
		(name, email, bio,password_hash, date_created, date_updated)
		VALUES ( $1, $2, $3, $4, $5, $6)
		Returning id`

	var id int

	//executing the query // QueryRowContext exec the query and returns one row back
	row := r.Db.QueryRowContext(ctx, q, u.Name, u.Email, u.Bio, hash, time.Now(), time.Now())

	//saving the value return by db in id var
	err = row.Scan(&id)

	if err != nil {
		log.Println(err)
		return &model.User{}, fmt.Errorf("account creation failed %w", err)
	}

	//converting id to string as our struct field store id in string format
	u.ID = strconv.Itoa(id)

	return &u, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	//this query is used to check whether a user exist in the db or not
	const q = `SELECT id,name,email,password_hash FROM users WHERE email = $1`

	var u model.User
	var passwordHash string
	//exec the query and storing the result in the struct
	err := r.Db.QueryRowContext(ctx, q, email).Scan(&u.ID, &u.Name, &u.Email, &passwordHash)
	if err != nil {
		log.Println(err)
		if err == sql.ErrNoRows {
			return "failed", errors.New("authentication failed")
		}
		return "failed", err
	}

	//comparing the hashed password in db and password provided by the user
	err = bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(password))

	if err != nil {
		log.Println(err)
		return "failed", errors.New("authentication failed")
	}

	//on successful login we will put data in the Claims var, we generate the token using the claims
	claims := jwt.RegisteredClaims{
		Issuer:    "microservice project",
		Subject:   u.Email,
		Audience:  jwt.ClaimStrings{"students"},
		ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),
		IssuedAt:  jwt.NewNumericDate(time.Now()),
	}

	// generate the token
	tkn, err := r.A.GenerateToken(claims)

	if err != nil {
		log.Println(err)
		return "", err
	}

	//returning jwt token if login details are correct
	return tkn, nil
}

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context) ([]*model.Article, error) {

	//check if user is logged in or not by validating the token
	claims, err := r.A.ValidateSession(ctx)
	if err != nil {
		log.Println(err)
		return nil, errors.New("login required")
	}

	// creating a struct to send it as json to article service
	var jsonReq = struct {
		Email string `json:"email"`
	}{
		Email: claims.Subject,
	}

	//converting struct into json
	b, err := json.Marshal(jsonReq)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	//creating context with timeout of 10sec // our remote service has to respond in this time or otherwise the request would be cancelled
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// construction of the request // we are using rest based approach to call article service
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, "http://article-service:8080/article/view", bytes.NewReader(b))
	if err != nil {
		log.Println(err)
		return nil, err
	}

	//making the request using http
	response, err := http.DefaultClient.Do(req)

	//this error occurs when remote service is unreachable or timeout happened
	//this does not signify if we had a problem in creating resource at the remote server
	if err != nil {
		log.Println(err)
		return nil, err
	}

	//reading the response body
	b, err = io.ReadAll(response.Body)
	if err != nil {
		log.Println(err)
		return nil, err
	}

	//if status code is above 299 which means something definitely went wrong
	if response.StatusCode > 299 {
		log.Println(string(b)) // logging what remote service has sent back as the response
		return nil, fmt.Errorf("view article failed %v", b)
	}
	var article []*model.Article

	//unmarshalling the data in the struct if everything is fine
	json.Unmarshal(b, &article)

	return article, nil
}

// Following is the resolver for the following field.
func (r *queryResolver) Following(ctx context.Context) ([]string, error) {
	//who user is following

	claims, err := r.A.ValidateSession(ctx)
	if err != nil {
		log.Println(err)
		return nil, errors.New("login required")
	}
	//connecting with the gRPC server
	conn, err := grpc.Dial("follower-service:5000", grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())
	if err != nil {
		log.Println(err)
		return nil, fmt.Errorf("can't dial connection to follower-service %w", err)

	}
	defer conn.Close()

	//registering the gRPC client
	c := proto.NewFollowUserServiceClient(conn)

	f := &proto.ListFollowingRequest{
		Email: &proto.Following{Email: claims.Subject},
	}

	//setting timeout of 10 sec
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	//calling the rpc
	res, err := c.ListFollowing(ctx, f)
	if err != nil {

		log.Println("following list", err)
		return nil, fmt.Errorf("can't fetch following list %w", err)
	}

	log.Println("following list fetch success", res)

	return res.FollowingList, nil
}

// Followers is the resolver for the followers field.
func (r *queryResolver) Followers(ctx context.Context) ([]string, error) {
	//who are user followers

	claims, err := r.A.ValidateSession(ctx)
	if err != nil {
		log.Println(err)
		return nil, errors.New("login required")
	}

	//connecting with the gRPC server
	conn, err := grpc.Dial("follower-service:5000", grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())
	if err != nil {
		return nil, fmt.Errorf("can't dial connection to follower-service %w", err)

	}
	defer conn.Close()

	//registering the gRPC client
	c := proto.NewFollowUserServiceClient(conn)

	f := &proto.ListFollowersRequest{
		Email: &proto.Follower{Email: claims.Subject},
	}
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	//calling the rpc
	res, err := c.ListFollowers(ctx, f)
	if err != nil {

		log.Println("follow user", err)
		return nil, fmt.Errorf("failed to fetch list of the followers %w", err)
	}

	log.Println("follow user success", res)

	return res.Followers, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
